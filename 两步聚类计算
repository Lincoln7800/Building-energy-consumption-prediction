#导入包
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
from sklearn import preprocessing
from sklearn import metrics

#数据读取与处理
data = pd.read_csv('./特征聚类1.csv',encoding='gbk')
data.head()
data_notitle = data.drop('room',axis = 1)
data_scaled = preprocessing.scale(data_notitle)
X = data_scaled
scores = []
for i in range(2,18):
    km = KMeans(n_clusters=i,init='k-means++',n_init=10,max_iter=300,random_state=0)
    km.fit(X)
    scores.append(metrics.silhouette_score(X,km.labels_ ,metric='euclidean'))

#指标计算与绘图
%matplotlib inline
plt.figure(dpi=150)
plt.plot(range(2,18),scores,marker = 'o')
plt.xlabel('Number of clusters')
plt.ylabel('silhouette_score')
plt.show
plt.savefig('图4.svg',format='svg')

#聚类计算
kmodel = KMeans(n_clusters = 2, n_jobs = 4, max_iter =1000 ) #n_jobs是并行数，一般等于CPU数较好
kmodel.fit(data_scaled) #训练模型
data_scaled = pd.DataFrame(data_scaled,columns = ['mean','total','median','Upper quantile','Lower quantile','extremum','Standard deviation'])
r1 = pd.Series(kmodel.labels_).value_counts()  #统计各个类别的数目
r2 = pd.DataFrame(kmodel.cluster_centers_)     #找出聚类中心
r = pd.concat([r2, r1], axis = 1)
r.columns = list(data_scaled.columns) + [u'类别数目']
r = pd.concat([data_scaled, pd.Series(kmodel.labels_, index = data_scaled.index)], axis = 1)  #详细输出每个样本对应的类别
r.columns = list(data_scaled.columns) + [u'聚类类别']
r.head()

#保存数据
julei2 = pd.DataFrame()
julei2['room'] = data['room']
julei2['cluster'] = r['聚类类别']
julei2.to_excel('一阶聚类.xlsx',encoding='gbk')

#读取数据
data_sum = pd.read_excel('./夏季2.xlsx',encoding = 'utf-8')
data_aut = pd.read_excel('./秋季2.xlsx',encoding='utf-8')
data_win = pd.read_excel('./冬季2.xlsx',encoding='utf-8')

#重新构建特征数组
new_data = pd.DataFrame(columns=['start'])
new_data['S_M'] = data_sum.mean(axis = 1)
new_data['S_S'] = data_sum.std(axis = 1)
new_data['A_M'] = data_aut.mean(axis = 1)
new_data['A_S'] = data_aut.std(axis = 1)
new_data['W_M'] = data_win.mean(axis = 1)
new_data['W_S'] = data_win.std(axis = 1)
new_data = new_data.drop('start',axis = 1)

#第二步聚类过程
data_scaled = preprocessing.scale(new_data)
data_scaled
X = data_scaled
scores = []
for i in range(2,18):
    km = KMeans(n_clusters=i,init='k-means++',n_init=10,max_iter=300,random_state=0)
    km.fit(X)
    scores.append(metrics.silhouette_score(X,km.labels_ ,metric='euclidean'))
%matplotlib inline
plt.figure(dpi=150)
plt.plot(range(2,18),scores,marker = 'o')
plt.xlabel('Number of clusters')
plt.ylabel('silhouette_score')
plt.show

kmodel = KMeans(n_clusters = 2, n_jobs = 4, max_iter =1000 ) #n_jobs是并行数，一般等于CPU数较好
kmodel.fit(data_scaled) #训练模型
data_scaled = pd.DataFrame(data_scaled,columns = ['S_M','S_S','A_M','A_S','W_M','W_S'])

r1 = pd.Series(kmodel.labels_).value_counts()  #统计各个类别的数目
r2 = pd.DataFrame(kmodel.cluster_centers_)     #找出聚类中心
r = pd.concat([r2, r1], axis = 1)
r.columns = list(data_scaled.columns) + [u'类别数目']
r = pd.concat([data_scaled, pd.Series(kmodel.labels_, index = data_scaled.index)], axis = 1)  #详细输出每个样本对应的类别
r.columns = list(data_scaled.columns) + [u'聚类类别']
r.head()
r2

from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
scaler = scaler.fit(new_data)
scaler.inverse_transform(r2)
#存储数据
julei = pd.DataFrame()
julei['room'] = data_sum['room']
julei['cluster'] = r['聚类类别']
julei.to_excel('二阶聚类2.xlsx',encoding='gbk')


